---
prev:
    link: ../02
    text: Объектно-ориентированная методология
next: false
#    link: ../02
#    text: 2. Объектно-ориентированная методология. Составные части объектного подхода
---

**Лекция**
# Составные части объектного подхода

## Классы

**Класс** — это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

Другими словами, класс — это абстрактное описание, по которому создаются объекты, работающие в коде. Его можно сравнить с чертежом, который описывает, как будет работать та или иная сущность.

В то же время объекты — реальные переменные, которые хранят в себе данные, выполняют функции и работают. Можно сказать, что это экземпляры техники, созданные по чертежам-классам.

::: info ПРИМЕР
Класс — автомобиль.
* Атрибутами (полями) класса будут являться двигатель, подвеска, кузов, четыре колеса и т. д.
* Методами класса будет «открыть дверь», «нажать на педаль газа», а также «закачать порцию бензина из бензобака в двигатель».

Первые два метода доступны для выполнения другим классам (в частности, классу «Водитель»). Последний описывает взаимодействия внутри класса и не доступен пользователю.
:::

## Объекты

**Объект** (или **экземпляр**) — это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.

Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. В данном примере, если класс — это некоторый абстрактный автомобиль из «мира идей», то объект — это конкретный автомобиль, стоящий у вас под окнами.

::: info ПРИМЕР
Машины, разработанные по вашим чертежам, сходят с конвейера. Каждая из них точно повторяет ваши чертежи. Все системы взаимодействуют именно так, как вы спроектировали.

Но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все эти номера разные, автомобили различаются цветом, а некоторые даже имеют литьё вместо штампованных дисков. Эти автомобили, по сути, являются объектами вашего класса.
:::

## Интерфейс

Когда мы подходим к автомату с кофе или садимся за руль, мы начинаем взаимодействие с ними. Обычно, взаимодействие происходит с помощью некоторого набора элементов: щель для приёмки монеток, кнопка выбора напитка и отсек выдачи стакана в кофейном автомате; руль, педали, рычаг коробки переключения передач в автомобиле. Всегда существует некоторый ограниченный набор элементов управления, с которыми мы можем взаимодействовать.

**Интерфейсом** класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ними.

Хорошим примером интерфейса может служить приборная панель автомобиля, которая позволяет вызвать такие методы, как увеличение скорости, торможение, поворот, переключение передач, включение фар и т. п. То есть все действия, которые может осуществить другой класс (в нашем случае — водитель) при взаимодействии с автомобилем.

При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью него решить будет не под сил. В то же время, если интерфейс будет гибким, то, скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, которые будут позволять делать очень многое, но использование его будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.

## Абстракция

**Абстракция** в объектно-ориентированном программировании (ООП) представляет собой концепцию, которая позволяет выделить важные характеристики и свойства объектов, игнорируя при этом ненужные детали.

Это позволяет разработчикам сосредотачиваться на ключевых аспектах системы, не углубляясь во все технические детали реализации.

Абстракция позволяет создавать модели, которые представляют сущности реального мира или концепции программы с точки зрения их существенных характеристик. Она определяет интерфейсы, методы и свойства объектов без указания деталей их реализации.

Таким образом, абстракция помогает скрыть сложность и упростить понимание системы, разделяя её на более простые и понятные компоненты.

::: info ПРИМЕР
Представьте, что у вас есть класс «Фигура», который имеет методы для вычисления площади и периметра. Вы можете создать конкретные подклассы, такие как «Круг», «Прямоугольник» и «Треугольник», которые наследуют методы из класса «Фигура».

В этом случае «Фигура» является абстракцией, которая предоставляет общий интерес для различных типов фигур, скрывая детали их реализации.

<<< ./snippets/snippet1.cpp {c++}

:::

## Инкапсуляция

**Инкапсуляция** — сокрытие внутренней реализации объекта от внешнего мира и предоставление интерфейса для взаимодействия с объектом.

Внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ к объектам возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

Инкапсуляцию также описывают как принцип разделения логики и поведения. Логика — то, как что-то устроено внутри. Поведение — то, как оно взаимодействует с другими сущностями. Разделение этих двух понятий упрощает взаимодействие объектов в коде.

Содержимое заключается в специальную программную оболочку, которая закрывает данные от внешних обращений. Принцип похож на автоматическую коробку передач: вам не приходится вручную управлять каждым элементом системы, более того — во время управления машиной к ним нет доступа. Есть только коробочка с рычагом, в качестве которой в программировании выступают открытые методы. Это понятно из названия: сущность оказывается «в капсуле», изолированной от внешнего мира.

## Поля

**Поля** — это переменные, «лежащие» внутри объектов. Они могут быть любого типа, а иногда и сами являются объектами. В переменных хранятся данные. Если какая-то переменная является свойством, её содержимое по умолчанию скрыто, то есть имеет место инкапсуляция.

## Методы

**Методы** — это функции внутри объектов. Они не просто хранят данные, а совершают какое-то действие. Важное отличие метода от обычной функции — его можно вызвать только для объекта, в котором он находится. Вызов метода отличается и внешне: в большинстве языков сначала пишется имя объекта, а потом, через точку — название метода и аргументы. А ещё для вызова метода ничего не нужно импортировать — всё уже есть в объекте, и это ещё один пример целостности инкапсулированной сущности.

## Геттеры и сеттеры

Поля по умолчанию скрыты от посторонних (инкапсуляция). Несмотрия на то что во многих случаях обратиться к ним напрямую через объект можно, в ООП это считается не лучшей практикой. Поэтому для работы со свойствами используют специальные методы — *геттеры* и *сеттеры*. Названия таких методов обычно начинаются со слов *get* и *set*.

**Геттер** — это метод объекта, который возвращает значение свойства этого объекта.

> Например, у объекта в свойстве *value* написано 15. Тогда геттер ``getValue()`` будет возаращать 15.

**Сеттер** — это метод, который изменяет значение свойства, задаёт его (set).

> Например, гипотетический метод ``setValue(x)`` будет менять значение свойства *value*. Аргумент *x* — это новое значение свойства, при вызове сеттера туда подставляются данные.

Геттеры и сеттеры важны для инкаспуляции, потому что позволяют не вмешиваться во внутреннюю структуру объекта. Они работают с ними сами, а значит, нет нужды "лезть" в объект извне — данные передадут геттеры и сеттеры. Так снижается риск ошибки при работе с данными в объекте.

## Модификаторы доступа

Теоретически обратиться в объект снаружи кода можно, но тут есть свои детали. Поведение по умолчанию может различаться для разных языков, но обычно возможность доступа к объекту можно настроить. Программист в коде сам описывает правила доступа.

Для этого используются специальные ключевые слова — **модификаторы доступа**.

Модификаторы могут иметь разный синтаксис в зависимости от языка. Классическое обозначение, принятое в языках C и C++:
* ``public`` — объект, функция или метод доступны для всех. Другие сущности могут читать оттуда данные и изменять их. Свойство публичного объекта можно получить, просто написав его название через точку:

  ``` :no-line-numbers
  <имя объекта>.<имя свойства>
  ```
  
  С таким данными легко работать, для них не нужны геттеры и сеттеры, но информация уязвима.

* ``private`` — содержимое объекта доступно только для других его составных частей. Например, метод объекта может вызывать данные из этого же объекта напрямую — а какой-нибудь код снаружи уже не может.

* ``protected`` — содержимое объекта доступно ему самому и его потомкам.

## Особенности реализации концепции инкаспуляции в разных языках

### Инкапсуляция в C++

В C++ инкаспуляция достигается через ключевые слова ``private``, ``protected`` и ``public``, которые управляют доступом к полям и методам класса.

* ``private``: поля и методы доступны только внутри самого класса.
* ``protected``: поля и методы доступны в классе и его потомках.
* ``public``: поля и методы доступны всем.

### Инкапсуляция в C#

C# предоставляет несколько модификаторов дляступа для управления уровнем доступа к членам класса.

* ``private`` — делает члены класса доступными только внутри этого класса.
* ``public`` — делает члены класса доступными для всех.
* ``protected`` — делает члены класса доступными для класса и его наследников.
* ``internal`` — доступен в пределах одной сборки (assembly).
* ``protected internal`` — доступен для наследников и внутри сборки.

<<< ./snippets/snippet2.cs {c#}

Если в блоках get и set свойства не реализуется никакая дополнительная логика, то допускается сокращённая форма записи свойства. Например, добавим в наш объект свойство *Name* (название здания) и применим сокращённую форму записи:

<<< ./snippets/snippet3.cs {c# 3}

Можно даже так:


<<< ./snippets/snippet4.cs {c#}

### Инакпсуляция в Java

В Java инкапсуляция реализована с помощью модификаторов доступа ``private``, ``protected``, ``public``, а также ``default`` (доступ только в пределах одного пакета).

<<< ./snippets/snippet5.java {java}

* **Модификатор ``private``.** Самый ограничивающий и наиболее часто используемый модификатор доступа ``private`` делает атрибут или метод доступным только в пределах одного и того же класса. Подклассы или любые другие классы в том же или другом пакете не могут получить доступ к этому атрибуту или методу. Используем его только для атриубтов и методов, которые мы больше никогда не захотим вызвать.

* **Модификатор ``no modifier``.** Отсутствие модификатора означает, что вы можете получить доступ к атрибутам или методам внутри вашего класса и из всех классов в одном пакете. Вот почему его часто называют *пакетным*.

* **Модификатор ``protected``.** Атрибуты и методы с модификатором доступа ``protected`` могут быть доступны внутри вашего класса всеми классами в одном пакете, а также всеми подклассами в том же или других пакетах. Этот модификатор, как правило, используется для внутренних методов, которые должны вызываться или переопределяться подклассами. Вы также можете использовать его, чтобы разрешить подклассам прямой доступ к внутренним атрибутам суперкласса.

* **Модификатор ``public``.** Доступ к методам и атрибутам, использующим модификатор ``public``, можно получить как в текущем классе, так и во всех других классах. Публичные методы и атрибуты становятся частью общедоступного API вашего класса и любого компонента, в котором вы их используете. Когда метод общедоступен, вам необходимо убедиться, что он хорошо задокументирован и надёжно обрабатывает любые входные значения. Также имейте в виду, что этот метод будет использоваться какой-то частью вашего приложения, что затруднит его изменение или удаление.

### Инкапсуляция в Python

В Python инкапсуляция носит более гибкий характер. В языке нет строгого контроля доступа к атрибутам объекта, но соглашение (начало имени с символа подчёркивания) указывает, что атриубыт считаются приватными. Python поддерживает ``protected`` и ``private`` уровни, но они действуют на уровне соглашений, а не строгой компиляции.

<<< ./snippets/snippet6.py

* Префикс ``_`` обозначает защищённые поля, а ``__`` — приватные.

* Поля не могут быть полностью скрыты от доступа извне, но программисты следуют соглашению, чтобы избежать прямого доступа.

### Инкапсуляция в Delphi (Object Pascal)

В Delphi для создани скрытых полей или методов их достаточно объявить в секции ``private``.

Для создания интерфейса доступа к скрытым полям в Delphi введены свойства (property).

<<< ./snippets/07.dpr {pascal}

### Инкапсуляция в JavaScript

В JavaScript до ES6 инкапсуляция напрямую не поддерживалась, и любой код мог иметь доступ к полям объекта. С появлением ES6 и позже ES2022, появилась возможность использовать приватные поля и методы через символ ``#``.

<<< ./snippets/08.js

* Приватные поля обозначаются символом ``#``.
* Ранее для инкапсуляции использовали замыкания (closures) или именование полей с нижним подчёркиванием по соглашению.

## Наследование

**Наследование** — это концепция, согласно которой одни классы, называемые *родительскими*, могут лежать в основе других — *дочерних*. При этом дочерние классы перенимают свойства и поведение своего родиетля.

Понятия:
* **Родительский класс (базовый, суперкласс):** класс, который передаёт свои свойства и методы.
* **Дочерний класс (производный):** класс, который наследует свойства и методы родительского класса.
* **Переопределение методов:** возможность дочернего класса изменять поведение методов родительского класса.

### Основные виды наследования

* **Одиночное наследование (Single Inheritance)** — когда класс наследуется от одного родительского класса.
* **Множественное наследование (Multiple Inheritance)** — когда класс наследует несколько родительских классов.

![](/media/images/oop-multiple-inheritance.png)

::: info ПРИМЕРЫ
Одиночное наследование:

<<< ./snippets/08.cpp {c++}

<br>
Множественное наследование:

<<< ./snippets/09.cpp {c++}
:::

### Проблемы, связанные со множественным наследованием

Одни языки поддерживают множественное наследование, другие — нет. Множественное наследоание требует тщательного проектирования, так как может привести к непредвиденным последствиям. Большинство таких последствий вызваны неоднозначностью в наследовании.

Может возникнуть неоднозначность, когда несколько родительских классов имеют метод с одним и тем же именем, например:

<<< ./snippets/10.cpp {c++}

При компиляции ``c54G.getID()`` компилятор смотрит, есть ли у *WirelessAdapter* метод ``getID()``. Этого метода у него нет, поэтому компилятор двигается по цепочке наследования вверх и смотрим, есть ли этот метод в каком-либо из родительских классов.

И здесь возникает проблема — ``getID()`` есть как у *USBDevice*, так и у *NetworkDevice*. Следовательно, вызов этого метода приведёт к неоднозначности, и мы получим ошибку, как как компилятор не будет знать, какую версию ``getID()`` ему вызывать.

Есть некоторый способ обойти эту проблему. Мы можем явно указать, какую версию ``getID()`` следует вызвать.

```c++ {3}
int main() {
  WirelessAdapter c54G(6334, 292651);
  std::cout << c54G.USBDevice::getID();
  return 0;
}
```

Хотя это решение довольно простое, но всё может стать намного сложнее, если наш класс будет иметь от 4 родительских классов, которые, в свою очередь, будут иметь свои родительские классы. Возможность возникновения конфликтов имён увеличивается экспоненциально с каждым добавленным родительским классом, и в каждом из таких случаев нужно будет явно указывать версии методов, которые следует вызывать, дабы избежать возможности возникновения конфликтов имён.

#### Проблема ромба (Diamond problem)

**Проблема ромба** — это классическая проблема в языках, которые поддерживают возможность множественного наследования. Проблема возникает, когда классы B и C наследуют A, а класс D наследует B и C.

К примеру, классы A, B и C определяют метод ``get_id()``.

Если ``get_id()`` будет вызываться классом D, *неясно, какой метод должен быть вызван — метод класса A, B или C*.

Разные языки по-разному подходят к решению этой проблемы. В C++ решение проблемы оставлено на усмотрение программиста.

::: info ПРИМЕР
Сканеры и принтера — это устройства, которые получают питание от розетки, поэтому они наследуют свойства *PoweredDevice*. Однако ксерокс (*Copier*) включает в себя функции как сканеров, так и принтеров.

В этом контексте возникает много проблем, включаяя неоднозначность при вызове методов и копирование данных *PoweredDevice* в класс *Copier* <u>дважды</u>. Хотя большинство из этих проблем можно решить с помощью явного указания, поддержка и обслуживание такого кода может привести к непредсказуемым затратам.

Дело в том, что в случае обычного наследования в классе-потомке (*Copier*) содержится отдельный экземпляр *PoweredDevice*.

Причём свойства каждого из них можно менять независимо.
:::

Проблема ромба должна быть предусмотрена на этапе проектирования. Её можно решить следующим образом:
* вызвать метод конкретного суперкласса;
* обратиться к объекту подкласса как к объекту определённого суперкласса;
* переопределить проблематичный метод в последнем дочернем классе (в коде — ``turn_on()`` в подклассе *Laptop*).

Пример:

<<< ./snippets/11.cpp {c++}

#### Проблема ромба: Конструкторы и деструкторы

Поскольку в C++ при инициализации объекта дочернего класса вызываются конструкторы всех родительских классов, возникает и другая проблема: конструктор базового клсса *Device* будет вызван дважды, в то время как идеологичски он должен бы быть один.

<<< ./snippets/12.cpp {c++}

### Виртуальное наследование в C++

Виртуальное наследование (virtual inheritance) предотвращает появление множественных объектов базового класса в иерархии наследования.


<<< ./snippets/13.cpp {c++ 14,21}

Теперь, часть *Device* объекта класса *Laptop::Computer* та же самая, что и часть *Device*, которая используется в *Laptop::Monitor*, и можно сказать, что *Laptop* имеет в своём представлении только одну часть *Device* и вызов ``Laptop::turn_on()`` становится однозначным.

Виртуальное наследование реализуется через добавление указателей в классы *Computer* и *Monitor*. За счёт этого обеспечивается не только исключение дублирования общей *Device* части для *Computer* и *Monitor*, но и простой механизм преобразования указателя (сслыки) на объект класса наследника в указатель (ссылку) на объект любого базового класса.


<<< ./snippets/14.cpp {c++}

### Особенности реализации концепции наследования в разных языках

#### Наследование в C++

C++ поддерживает наследование через ключевые слова ``public``, ``protected`` или ``private``, определяющие уровень доступа к родительскому классу.

```c++
class A {};               // базовый класс
class B : public A {};    // public-наследование
class C : protected A {}; // protected-наследование
class Z : private A {};   // private-наследование
```

Если класс объявлен как базовый для другого класса со спецификатором доступа...

* ...``public``:
  * ``public``-члены базового класса — доступны как ``public``-члены производного класса;
  * ``protected``-члены базового класса — доступны как ``protected``-члены производного класса;
* ...``protected``:
  * ``public``- и ``protected``-члены базового класса — доступны как ``protected``-члены производного класса;
* ...``private``:
  * ``public``- и ``protected``-члены базового класса — доступны как ``private``-члены производного класса.

``` c++
class Vehicle {
public:
  void start() {
    cout << "Vehicle started" << endl;
  }
};

class Car : public Vehicle {
public:
  void honk() {
    cout << "Car is honking" << endl;
  }
}
```

##### Память

* **Стек.** В C++ объекты могут создаваться на стеке при прямом объявлении переменной. Это более эффективно по скорости, так как операции со стеком быстры, но объект автоматически удаляется по завершении его области видимости.

```c++
void func() {
  int a = 10;   // создан на стеке
  MyClass obj;  // объект класса создан на стеке
}   // a и obj уничтожаются, когда функция заканчивается
```

* **Куча (Heap).** Объекты могут создаваться в куче с помощью оператора ``new``. Они живут, пока не будут явно удалены с помощью ``delete``.

```c++
void func() {
  MyClass* obj = new MyClass();   // создано в куче
  delete obj;  // удаляем вручную
}
```

В C++ каждый объект занимает непрерывный блок памяти, который содержит:
* поля класса (как родительские, так и дочерние);
* виртуальные функции организуются через таблицу виртуальных функций (vtable), если класс содержит хотя бы одну виртуальную функцию.

Если дочерний класс наследует поля и методы родительского класса, они располагаются в памяти сразу после полей родительского класса. Это делает доступ к полям и методам родительского класса через объект дочернего класса возможным без дополнительного накладного расхода.

```c++
class A {
  int a;    // поле A
}

class B : public A {
  int b;    // поле B
}

// в памяти: сначала a, потом b (если нет виртуальных функций)
```

При использовании *виртуальных* методов для каждой объектной модели создаётся таблица виртуальных методов (vtable), которая содержит укзаатели на функции. Объект будет содержать указатель на эту таблицу, что моет немного увеличить его размер в памяти.