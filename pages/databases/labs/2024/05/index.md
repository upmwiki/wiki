---
prev:
    link: ../04
    text: 4. SQL (PL/SQL)
next:
    link: ../06
    text: 6. Работа с бинарными и сильноветвящимися деревьями
---

**Лабораторная работа 5**

# XML

## Варианты

::: warning ВАЖНО
При выполнении данной лабораторной работы нужно обращаться к схеме ``ED_SALES``. Её можно найти в SQL Developer в разделе "Other Users".
:::

### Вариант 1

Сформировать XML-документ со следующей структурой.

```xml
<Заказы>
    <Заказ номер="ИД ЗАКАЗА" клиент="ИМЯ ИЛИ НОМЕР КЛИЕНТА">
        <Позиция номер="НОМЕР ПОЗИЦИИ ЗАКАЗА" количество="КОЛИЧЕСТВО КУПЛЕННОГО ТОВАРА" цена="ЦЕНА ТОВАРА">НАИМЕНОВАНИЕ ИЛИ ИД ТОВАРА</Позиция>
        ...
        ...
    </Заказ>
    ...
    ...
</Заказы>
```

### Вариант 2

Сформировать XML-документ со следующей структурой.

```xml
<Отделы>
    <Отдел номер="НОМЕР ОТДЕЛА" название="НАИМЕНОВАНИЕ">
        <Сотрудник номер="НОМЕР СОТРУДНИКА" уровень_оплаты="УРОВЕНЬ ЗАРПЛАТЫ">ИМЯ СОТРУДНИКА</Сотрудник >
        ...
        ...
    </Отдел>
    ...
    ...
</Отделы>
```

### Вариант 3

Сформировать XML-документ со следующей структурой.

```xml
<Продукты>
    <Продукт номер="НОМЕР ПРОДУКТА" название="НАИМЕНОВАНИЕ">
        <Цена дата_начала="ДАТА НАЧАЛА ДЕЙСТВИЯ ЦЕНЫ" дата_окончания="ДАТА ОКОНЧАНИЯ ДЕЙСТВИЯ ЦЕНЫ">РОЗНИЧНАЯ ЦЕНА</Цена>
        ...
        ...
    </Продукт>
    ...
    ...
</Продукты>
```

### Вариант 4

Сформировать XML-документ со следующей структурой.

```xml
<Клиенты>
    <Клиент номер="ИМЯ ИЛИ НОМЕР КЛИЕНТА">
        <Заказ номер="НОМЕР ЗАКАЗА" дата_заказа="ДАТА ЗАКАЗА" дата_доставки="ДАТА ДОСТАВКИ">НОМЕР СЧЕТА</Заказ>
        ...
        ...
        </Клиент>
    ...
    ...
</Клиенты>
```


### Вариант 5

Сформировать XML-документ со следующей структурой.

```xml
<Уровни зарплаты>
    <Уровень нижний_предел="НИЖНИЙ ПРЕДЕЛ" верхний_предел="ВЕРХНИЙ ПРЕДЕЛ">
        <Сотрудник номер="НОМЕР СОТРУДНИКА" должность="ДОЛЖНОСТЬ">ИМЯ СОТРУДНИКА</Сотрудник>
        ...
        ...
    </Уровень зарплаты>
    ...
    ...
</Уровни зарплаты>
```


### Вариант 6

Сформировать XML-документ со следующей структурой.

```xml
<Должности>
    <Должность название="ДОЛЖНОСТЬ">
        <Сотрудник номер="НОМЕР СОТРУДНИКА" номер_отдела="НОМЕР ОТДЕЛА" >ИМЯ СОТРУДНИКА</Сотрудник>
        ...
        ...
    </Должность>
    ...
    ...
</Должности>
```

## Методические указания
* https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB4994 — подробная офф. документация по работе с XML с примерами
* http://citforum.ru/database/oracle/xml-oracle/ — пункт "Преобразование из табличной формы в XMLTYPE" с примерами

## Защита

::: details В чём разница между элементами и атрибутами?

В XML *элементы* позволяют описать сущности (какие-то объекты), а *атрибуты* — их свойства.

Например, если нужно представить информацию о сотруднике в виде XML-документа, то это можно сделать следующим образом:

```xml
<Сотрудник номер_сотрудника="123456" номер_отдела="15">
    Иванов Иван Иванович
</Сотрудник>
```

Здесь сам сотрудник описывается путём создания элемента ``<Сотрудник>``, а информация о сотруднике (его свойства), такая как его номер и номер его отдела, представлена в виде атрибутов.

В Oracle SQL создать элемент можно при помощи функции ``XMLELEMENT``, а добавить атрибут для него — с помощью функции ``XMLATTRIBUTE``.
:::

:::: details Какие функции можно использовать для преобразования строк таблицы в XML-документ?
Для выполнения данной лабораторной работы достаточно использовать функции ``XMLELEMENT``, ``XMLATTRIBUTES`` и ``XMLAGG``. Также могут спросить про ``XMLFOREST`` и ``XMLROOT``.

* **XMLELEMENT.** ``XMLELEMENT`` используется для создания XML-элементов. Эта функция принимает имя элемента, опционально набор атрибутов и содержимое элемента. Она возвращает экземпляр типа XMLType.

  Например, можно создать элемент ``<Employee>`` с атрибутами и содержимым, используя следующий синтаксис:
   
  ::: code-group
  ```sql [SQL-запрос]
  SELECT XMLELEMENT(
      "Employee",
      XMLATTRIBUTES(emp_id AS "ID"),
      emp_name
  )
  FROM employees;
  ```

  ``` xml [Результат (XML)]
  <Employee ID="1">John Doe</Employee>
  <Employee ID="2">Jane Smith</Employee>
  ```
  :::

* **XMLATTRIBUTES.** ``XMLATTRIBUTES`` позволяет добавлять атрибуты к XML-элементам, созданным с помощью ``XMLELEMENT``.

  В предыдущем примере ``ID`` (т. е. ``emp_id``) будет атрибутом элемента ``<Employee>``.

* **XMLAGG.** ``XMLAGG`` используется для агрегации нескольких XML-элементов в один XML-документ. Эта функция полезна, когда нужно объединить результаты из нескольких строк в один XML-документ.

  ::: code-group
  ```sql [SQL-запрос]
  SELECT XMLAGG(XMLELEMENT("Employee", emp_name)) AS Employees
  FROM employees;
  ```

  ``` xml [Результат (XML)]
  <Employees>
      <Employee>John Doe</Employee>
      <Employee>Jane Smith</Employee>
  </Employees>
  ```
  :::

* **XMLFOREST.** ``XMLFOREST`` позволяет создавать XML-элементы для каждого указываемого столбца. Каждый столбец становится отдельным элементом в результирующем XML.

  ::: code-group
  ```sql [SQL-запрос]
  SELECT XMLFOREST(emp_name AS "Name", emp_id AS "ID")
  FROM employees;
  ```

  ``` xml [Результат (XML)]
  <Name>John Doe</Name>
  <ID>1</ID>
  <Name>Jane Smith</Name>
  <ID>2</ID>
  ```
  :::

  Этот запрос создаст XML-элементы ``<Name>`` и ``<ID>`` для каждого сотрудника.

* **XMLROOT.** ``XMLROOT`` добавляет информацию о составляемом XML-документе, такую как версия XML, используемая кодировка и т. д. в начало этого документа.

  ::: code-group
  ```sql [SQL-запрос]
  SELECT XMLROOT(
      XMLAGG(XMLELEMENT("Employee", emp_name)),
      VERSION '1.0',
      ENCODING 'UTF-8'
  ) AS XML_Document
  FROM employees;
  ```

  ``` xml [Результат (XML)]
  <?xml version="1.0" encoding="UTF-8"?>
  <Employees>
      <Employee>John Doe</Employee>
      <Employee>Jane Smith</Employee>
  </Employees>
  ```
  :::
::::

:::: details Как работает конструкция ``XMLAGG``? Использование группировки вместе с ``XMLAGG``

``XMLAGG`` — это агрегатная функция в Oracle SQL, которая позволяет объединить несколько XML-элементов в один XML-документ. Она принимает коллекцию XML-элементов и возвращает их в виде одного агрегированного XML-документа. Это особенно полезно, когда необходимо собрать данные из нескольких строк в одну структуру.

При использовании ``XMLAGG`` в сочетании с группировкой можно агрегировать данные по определённым критериям.

::: code-group
```sql [SQL-запрос]
SELECT XMLELEMENT("Должности",
    XMLAGG(
        XMLELEMENT("Должность", XMLATTRIBUTES(должность AS "название"),
            XMLAGG(
                XMLELEMENT("Сотрудник", 
                    XMLATTRIBUTES(ном_сотр AS "номер", ном_отдела AS "номер_отдела"),
                    фамилия
                )
            )
        )
    )
) AS xml_output
FROM ED_SALES.Сотрудники
GROUP BY должность;
```

``` xml [Результат (XML)]
<Должности>
    <Должность название="АНАЛИТИК">
        <Сотрудник номер="7838" номер_отдела="20">СКОТТ</Сотрудник>
        <Сотрудник номер="7902" номер_отдела="20">ФОРД</Сотрудник>
    </Должность>
    <Должность название="КАССИР">
        <Сотрудник номер="7950" номер_отдела="40">ХАЙК</Сотрудник>
        <Сотрудник номер="7702" номер_отдела="40">МАКЛАЙ</Сотрудник>
    </Должность>
    <Должность название="КЛЕРК">
        <Сотрудник номер="7990" номер_отдела="40">ДУЛЛИТ</Сотрудник>
        <Сотрудник номер="7934" номер_отдела="10">МИЛЛЕР</Сотрудник>
        <Сотрудник номер="7900" номер_отдела="30">ДЖЕЙМС</Сотрудник>
        <Сотрудник номер="7876" номер_отдела="20">АДАМС</Сотрудник>
        <Сотрудник номер="7369" номер_отдела="20">СМИТ</Сотрудник>
    </Должность>
    <Должность название="МЕНЕДЖЕР">
        <Сотрудник номер="7991" номер_отдела="40">ТУРС</Сотрудник>
        <Сотрудник номер="7782" номер_отдела="10">КЛАРК</Сотрудник>
        <Сотрудник номер="7698" номер_отдела="30">БЛЕЙК</Сотрудник>
        <Сотрудник номер="7566" номер_отдела="20">ДЖОНС</Сотрудник>
    </Должность>
    <Должность название="ОПЕРАЦИОНИСТ">
        <Сотрудник номер="7940" номер_отдела="40">ТОМАСОН</Сотрудник>
        <Сотрудник номер="7701" номер_отдела="40">МАРТИНС</Сотрудник>
        <Сотрудник номер="7700" номер_отдела="40">ХАРД</Сотрудник>
    </Должность>
    <Должность название="ПРЕЗИДЕНТ">
        <Сотрудник номер="7839" номер_отдела="10">КИНГ</Сотрудник>
    </Должность>
    <Должность название="ПРОДАВЕЦ">
        <Сотрудник номер="7935" номер_отдела="20">СМИТ</Сотрудник>
        <Сотрудник номер="7844" номер_отдела="30">ТЮРНЕР</Сотрудник>
        <Сотрудник номер="7654" номер_отдела="30">МАРТИН</Сотрудник>
        <Сотрудник номер="7521" номер_отдела="30">ВАРД</Сотрудник>
        <Сотрудник номер="7499" номер_отдела="30">АЛЛЕН</Сотрудник>
        <Сотрудник номер="7936" номер_отдела="20">ФОРД</Сотрудник>
    </Должность>
</Должности>
```
:::
::::

:::: details Что такое ``XMLFOREST`` и ``XMLELEMENT`` и в чём разница между ними?
``XMLELEMENT`` и ``XMLFOREST`` — это функции в Oracle SQL, которые используются для создания XML-элементов, но они имеют разные цели и способы работы.

``XMLELEMENT`` используется для создания одного XML-элемента. Эта функция принимает имя элемента и может включать в себя атрибуты и содержимое.

::: code-group
```sql [SQL-запрос]
SELECT XMLELEMENT("Employee", XMLATTRIBUTES(emp_id AS "ID"), emp_name)
FROM employees;
```

``` xml [Результат (XML)]
<Employee ID="1">John Doe</Employee>
```
:::

В этом примере создаётся элемент ``<Employee>``, который содержит атрибут ``ID`` и текстовое содержимое ``emp_name``.

``XMLFOREST`` используется для создания нескольких XML-элементов из списка столбцов. Каждый передаваемый в качестве аргумента столбец становится отдельным элементом в результирующем XML.

::: code-group
```sql [SQL-запрос]
SELECT XMLFOREST(emp_name AS "Name", job_title AS "JobTitle")
FROM employees;
```

``` xml [Результат (XML)]
<Name>John Doe</Name>
<JobTitle>Software Engineer</JobTitle>
```
:::

В этом примере для каждого сотрудника создаются два элемента: ``<Name>`` и ``<JobTitle>``, которые содержат соответствующие значения.
::::

::: details *[без ответа]* Что такое ``XMLATTRIBUTES`` и ``XMLELEMENT`` и в чём разница между ними, куда записываются их данные?
:::

::: details *[без ответа]* Как проверить, пустой ли ``XMLELEMENT``? Какие функции для этого нужны?
:::

::: details Что такое ``XMLTYPE``?
Функция ``XMLTYPE`` позволяет представить XML-документ в виде набора столбцов.
:::

::: details Что такое ``XMLROOT``?
Функция ``XMLROOT`` добавляет информацию о составляемом XML-документе, такую как версия XML, используемая кодировка и т. д. в начало этого документа.

Ниже приведён пример того, как может выглядеть подобная информация в XML-файле.

```xml
<?xml version="1.0" encoding="utf-8" ?>
```
:::

:::: details Как преобразовать XMLTYPE в XML-строку?
Использовать ``getClobVal()``.

```sql
SELECT xml_column.getClobVal() AS xml_string
FROM table;
```

::::

::: details В чём разница между ``XMLELEMENT`` и ``XMLAGG``?
``XMLELEMENT`` создаёт отдельные XML-элементы, тогда как ``XMLAGG`` агрегирует (объединяет, оборачивает) эти элементы в один XML-объект.
:::