---
prev:
    link: ../03
    text: 3. SQL (DDL, DCL)
next:
    link: ../05
    text: 5. XML
---

**Лабораторная работа 4**

# PL/SQL

## Варианты

### Вариант 1

1. Написать процедуру, выполняющую следующую операцию:
   > Для клиента определяется продавец, заключивший максимальное количество сделок. 
   >
   > Во всех заказах клиента проставляется этот продавец.
   >
   > Если несколько продавцов имеют для клиента одинаковое количество сделок, то без изменений.

2. Написать функцию, вычисляющую значение средней суммы сделок за заданный период для определенного продавца.

3. Написать триггер, вставляющий запись в таблицу *Audit(user_name, date, onum)* при каждой вставке строки в таблицу *Orders*. (функция ``user``, таблица ``dual``)

4. Написать триггер автоматически устанавливающий уникальное значение cnum при вставке в таблицу *Customers*. (последовательности (sequence))

5.	Добавить в таблицу *Customer* столбец *ord_number*.

    Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Orders*.


### Вариант 2

1. Написать процедуру, выполняющую следующую операцию:
   > Создать альбом из трех песен которые наиболее часто встречаются в других альбомах.

2. Написать функцию, вычисляющую отношение продолжительности звучания определенного альбома к средней величине продолжительности звучания альбома.

3. Написать триггер, вставляющий запись в таблицу *Аудит(имя_польз, дата, код_альб)* при каждой вставке строки в таблицу *Альбом*. (функция ``user``, таблица ``dual``)

4. Написать триггер, автоматически устанавливающий уникальное значение *код_альб* при вставке в таблицу *Альбом*. (последовательности (sequence))

5. Добавить в таблицу *Альбом* столбец *кол_песен*.
   
   Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Песня_из_альбома*.


### Вариант 3

1. Написать процедуру, выполняющую следующую операцию:
   > Для двух любых помещений поменять их виды местами при условии, что они находятся в одном здании.

2. Написать функцию, вычисляющую значение средней площади помещений за заданный период для определенного здания.

3. Написать триггер, вставляющий запись в таблицу *UserData (user_name, date, id_building)* при каждой вставке строки в таблицу *Building*. (функция ``user``, таблица ``dual``)

4. Написать триггер автоматически устанавливающий уникальное значение *id_building* и *id_premises* при вставке в таблицу *Building* и *Premises*. (последовательности (sequence))

5. Добавить в таблицу *Premises* столбец *prem_number*.

   Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Kind_premises*.


### Вариант 4

1. Написать процедуру, выполняющую следующую операцию:
   > Заселить человека в комнату:
   > * если у человека есть текущее проживание, то выселить его с предыдущей комнаты;
   > * если предыдущего проживания нету – заселить в любую свободную комнату.

2. Написать функцию, вычисляющую количество свободных комнат, по выбранному зданию на указанную дату.

3. Написать триггер, устанавливающий значение поля *id_bas_sal_date* на текущую дату при добавлении записи в *Residing*.

4. Написать триггер автоматически устанавливающий уникальное значение *id_settling* при вставке в таблицу *Settling*. (последовательности (sequence))

5. Добавить в таблицу Warrant столбец *Kol_war*.

   Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Settling*.


### Вариант 5

1. Написать функцию, вычисляющую значение средней суммы сделок за заданный период для всех продавцов.

2. Написать триггер, вставляющий запись в таблицу *UserSample (user_name, date, cnum)* при каждой вставке строки в таблицу *Customer*. (функция ``user``, таблица ``dual``)

3. Написать триггер, автоматически устанавливающий уникальное значение onum при вставке в таблицу *Orders*. (последовательности (sequence))

4. Добавить в таблицу *Salespeople* столбец *sal_number*.

   Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Orders*.

5. Написать процедуру, выполняющую следующую операцию:

   > Для клиента определяется продавец, заключивший минимальное количество сделок.
   >
   > Во всех заказах клиента проставляется этот продавец.
   >
   > Если несколько продавцов имеют для клиента одинаковое количество сделок, то выбрать того продавца, у которого в имени больше букв.


### Вариант 6

1. Написать триггер, автоматически устанавливающий уникальное значение *id_building* при вставке в таблицу *Building*. (последовательности (sequence))

2. Написать функцию, вычисляющую значение общей площади всех помещений за заданный период для всех зданий.

3. Написать процедуру, выполняющую следующую операцию:
Для двух любых зданий поменять их виды местами при условии, что поле примечание (*Building.b_note*) не пусто.

4. Написать триггер, вставляющий запись в таблицу *UsersSampleData (user_name, date, id_premises)* при каждой вставке строки в таблицу *Premises*. (функция ``user``, таблица ``dual``)

5. Добавить в таблицу *Building* столбец *build_number*.

   Написать триггер, увеличивающий на единицу значение этого столбца при вставке записи в таблицу *Kind_building*.


## Защита

Ниже приведены вопросы, которые задавались во время защиты лабораторной работы.

::: details Какие существуют виды блоков PL/SQL?
Программа на PL/SQL состоит из блоков (*анонимных* или *именованных*). Блок может содержать вложенные блоки, называемые иногда *подблоками*.

*Анонимные* блоки создаются, как правило, динамически и выполняются один раз. *Именованные* блоки — это анонимные блоки с метками, дающими блокам имена.

PL/SQL допускает следующие виды блоков:
* *процедуры* — именованные блоки, которые могут выполнять какие-либо действия, не возвращая никакого значения.
* *функции* — именованные блоки, которые могут выполнять какие-либо действия и возвращают какое-то значение.
* *триггеры* — именованные блоки, выполняемые неявно, всякий раз, когда происходит событие, запускающее этот триггер, причём использование аргументов не допускается.

:::

::: details Что означает условие ``FOR EACH ROW`` в триггере? Для чего она нужна? Если ли другие команды помимо неё?

Триггеры бывают двух видов:
* *операторные* — активизируется один раз до или после выполнения оператора (``SELECT``, ``INSERT`` и т. д.);
* *строковые* — срабатывает каждый раз для строки, обрабатываемой активизирующим оператором.

По умолчанию триггеры определены как операторные. Условие ``FOR EACH ROW`` позволяет сделать триггер строковым.

Условие ``WHEN`` можно использовать только для строковых триггеров.
:::

::: details Для чего в триггерах используются такие операторы, как ``:new``, ``:old``? Что это такое и как они работают?

Внутри строкового триггера можно обращаться к строке, обрабатываемой в данный момент. Для этого существуют две *псевдозаписи*: ``:new`` и ``:old``. Они используются для доступа к значениям строки до и после её изменения соответственно. ``:old`` содержит старые значения полей, которые вставляются или обновляются, а ``:new`` — новые значения.
:::

::: details Можно ли ``:old`` и ``:new`` использовать в ``UPDATE``?

Да, обе псевдозаписи можно использовать в ``UPDATE``. Псевдозапись ``:old`` позволяет обращаться к строке до её изменения оператором, а ``:new`` — к уже изменённой строке.
:::

::: details Чем отличается триггер от процедуры?
Триггер и процедура — это два вида именованных блоков в PL/SQL:
* *процедуры* — именованные блоки, которые могут выполнять какие-либо действия, не возвращая никакого значения.
* *триггеры* — именованные блоки, выполняемые неявно, всякий раз, когда происходит событие, запускающее этот триггер, причём использование аргументов не допускается.
:::

::: details Какие существуют именованные и неименованные блоки?
:::

::: details Что такое транзакция? Как она работает? Что такое ``COMMIT`` и ``ROLLBACK``?
**Транзация** — это набор операций. Она может начаться либо с вызовом первого оператора в запросе, либо после завершения предыдущего запроса.

Завершить запрос можно с помощью операторов ``COMMIT`` и ``ROLLBACK``. Первый оператор сохранит изменения в базу данных, а второй — отменит их.
:::

::: details Что такое ``INTO`` в ``SELECT``?
``INTO`` позволяет указать название переменной, в которую нужно сохранить результат выполнения запроса ``SELECT``.
:::

::: details Чем отличается триггер от функции?
Триггер вызывается автоматически, а функция — вручную. Также триггер не принимает и не возвращает никаких значений, а функция может принимать и должна вернуть какое-либо значение.
:::

::: details Что такое курсор? Для чего он нужен и как он работает?
*Курсор* — это механизм, позволяющий обрабатывать отдельные строки, полученные в результате ``SELECT``-запроса.

Курсоры бывают двух видов:
* *неявные* — при их использовании в качестве результата выдаётся только одна строка;
* *явные* — с их помощью можно возвращать несколько строк. Возможно параллельная обработка нескольких запросов посредством открытия нескольких курсоров. Возможно пакетное извлечение данных (с помощью предложения ``BULK COLLECT``).


:::

::: details Что такое анонимный блок?
*Анонимный блок* — это блок, который не записывается в память. У него нет имени и он выполняется один раз.

*Именованные блоки* — это анонимные блоки, которым присваивается имя, что позволяет обращаться к ним множество раз.
:::