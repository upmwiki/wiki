---
prev: false
next: false
---

# Методические указания

**Цель работы:** изучение хранимых процедур, функций и триггеров и приобретение навыков их создания с помощью PL/SQL инструментария.

## Общие положения

Подпрограмма, явно создаваемая (``CREATE``) с помощью **PL/SQL** инструментария, называется *хранимой подпрограммой*. Такая подпрограмма, один раз откомпилированная и сохранённая в базе данных, является объектов базы данных, и к ней могут обращаться любые приложения, соединённые с этой базой данных.

PL/SQL имеет два типа подпрограмм, которые называются *процедурами* и *функциями*. Подпрограммы способствуют разработке приложений за счёт изолирования операций.

Процедуры и функции — это поименованные блоки PL/SQL, которые принимают параметры и могут быть вызваны с возвратом. Обычно подпрограммы используются для выполнения действия, а функции — для вычисления значения (возвращают значения). Процедуры могут и модифицировать данные, и запрашивать их, но только не одновременно и то и другое.

Процедуры и функции предоставляют расширяемость, позволяя привязывать средства PL/SQL к потребностям пользователя. Они также обеспечивают надёжность, сопровождаемость и производительность приложений.

## Структура PL/SQL блока

Структура анонимного PL/SQL блока включает три раздела:
```sql
[ DECLARE
    /* раздел объявлений*/ ]
BEGIN
   /* исполняемый раздел */
[ EXCEPTION
    /* раздел обработки исключительных ситуаций */ ]
END;
```

## Использование %TYPE

Часто при использовании переменных в PL/SQL им необходимо присвоить тот же тип, который имеет соответствующий столбец таблицы. В таком случае приложение во многом становится независимым от изменений структуры таблицы, данные из которой оно использует.

Чтобы обеспечить подобную связь между переменной и столбцом таблицы и используют атрибут ``%TYPE``. Он добавляется к ссылке на столбец таблицы или к друой переменной и возвращает тип переменной.

Например:

```sql
DECLARE
    v_FIRSTNAME VARCHAR2(25) students.first_name%TYPE;
```

Таким образом, переменная ``v_FIRSTNAME`` будет иметь тот же тип, что и столбец *first_name* таблицы *students*. Тип определяется всякий раз, когда данный блок выполняется для анонимных и именованных блоков и когда и компилируются хранимые объекты.

Например:

```sql{3,8,14}
-- 1
DECLARE
    v_RoomID classes.room_id.%TYPE;
    -- возвращает тип столбца room_id таблицы classes

-- 2
DECLARE
    v_RoomID2 v_RoomID.%TYPE;
    -- возвращает тип переменной v_RoomID

-- 3
DECLARE
    v_TEMPVAR number(7, 3) not null :=12.3;
    v_ANOTHERVAR v_TEMPVAR%TYPE;
    -- возвращает number(7, 3)
```

Если данный атрибут ``%TYPE`` используется для переменной (столбца), которая содержит ограничение ``not null``, то возвращаемый тип не имеет этого ограничения.

## Использование «последовательности»

**Последовательность** — это объект базы данных, используемый для автоматического генерирования уникальных значений первичного ключа таблиц. Создание последовательности имеет следующий синтаксис:

```sql
CREATE SEQUENCE название_последовательности
START WITH начальное_число
INCREMENT BY шаг_изменения;
```

где
* ``название_последовательности`` — имя объекта, которое будет использоваться в качестве последовательности;
* ``начальное_число`` — число, с которого начинают генерироваться значения последовательности;
* ``шаг_изменения`` — шаг изменения генерируемых значений последовательности.

Например:

```sql
CREATE SEQUENCE student_SEQUENCE
START WITH 10000
INCREMENT BY 1;
-- создаётся последовательность student_SEQUENCE, начиная с 1000 с шагом 1
```

## Использование конструкции SELECT ... INTO

В PL/SQL есть возможность выбирать результаты запроса в переменную, которую необходимо перед этим объявить. Данная конструкция имеет следующий синтаксис:

```sql
SELECT { список_выбора }
INTO { список_переменных }
FROM { список_таблиц }
[ WHERE { условие_поиска } ];
```

где
* ``список_выбора`` — имена столбцов, перечисленные через запятую;
* ``список_переменных`` — имена переменных, в которые будет считываться содержимое столбцов (переменные и столбцы должны быть совместимы по типу данных и количеству);
* ``список_таблиц`` — имена таблиц, перечисленные через запятую;
* ``условие_поиска`` — логическое условие, которое задаёт критерий отбора.

Записанный таким образом оператор ``SELECT`` должен выбирать не более одной строки.

Например:

```sql
DECLARE
    /* Declare variables to be used in this block. */
    v_Num1      NUMBER := 1;
    v_String1   VARCHAR2(50) := 'Hello World!';
    v_OutputStr VARCHAR2(50);
BEGIN
    /* First, insert two rows into temp_table, using the values of the variables. */
    INSERT INTO temp_table (num_col, char_col)
    VALUES (v_Num1, v_String1);
    /* Now query temp_table for the two rows we just inserted, and output them to the screen using the DBMS_OUTPUT package. */
    SELECT char_col
        INTO v_OutputStr
        FROM temp_table
        WHERE num_col = v_Num1;
END;
```

Данный блок позволяет вначале ввести в столбцы *num_col*, *char_col* таблицы *temp_table* значения переменных *v_Num1*, *v_String1*. Затем с помощью конструкции ``SELECT ... INTO`` считать значение *v_String1* в переменную *v_OutputStr*.

## Блок PL/SQL

Базовой единицей программы на PL/SQL является **блок**. Блоки могут быть вложенными или следующими один за другим. PL/SQL допускает следующие виды блоков:
* *анонимные* — создаются, как правило, динамически и выполняются один раз;
* *именованные* — анонимные блоки с метками, дающими блокам имена;
* *подпрограммы* — это процедуры, модули и функции, хранимые в базе данных (не изменяются после своего создания и выполняются многократно явным образом посредством вызова);
* *триггеры* — именованные блоки, хранимые в базе дынных.

## Управляющие структуры

### IF-THEN-ELSE

Общий синтаксис следующий:

```sql
IF логическое_выражение 1 THEN
последовательность_операторов1;
[ ELSIF логическое_выражение 2 THEN
последовательность_операторов; ]
    ...
[ ELSE последовательность_операторов3; ]
END IF;
```

где
* ``логическое_выражение`` — любое выражение, результатом которого является логическое значение;
* ``последовательность_операторов`` — операторы, которые должны быть выполнены.

Условия ``ELSIF`` и ``ELSE`` необязательны, причём условий ``ELSIF`` может быть сколь угодно много.

```sql
DECLARE
    v_NumberSeats rooms.number_seats%TYPE;
    v_Comment VARCHAR2(35);
BEGIN
    /* данный анонимный блок считывает заполненность аудитории с номером 99999 в
    переменную v_NumberSeats и в зависимости от считанного присваивает переменной
    v_Comment значение. */
    SELECT number_seats
        INTO v_NumberSeats
        FROM rooms
        WHERE room_id = 99999;
    IF v_NumberSeats < 50 THEN
        v_Comment := 'Fairly small';
    ELSIF v_NumberSeats < 100 THEN
        v_Comment := 'A little bigger';
    ELSE
        v_Comment := 'Lots of room';
    END IF;
END;
```

## Циклы

### Простые циклы

```sql
LOOP последовательность_операторов;
END LOOP;
```

``последовательность_операторов`` — будет выполняться бесконечно долго, так как в этом цикле отсутствует условие его завершения. Такое условие можно предусмотреть, если добавить оператор ``EXIT`` (выход), имеющий следующий синтаксис (``WHEN`` — когда):

```sql
EXIT [ WHEN условие ]
```

Таким образом, выход произойдёт при выполнении ``условия``.

```sql
/*введём в таблиц ЗАЧЕТ 20 новых строк, у которых будет заполнено только поле ключа */
DECLARE
V_COUNTER BINARY_INTEGER := 1;
BEGIN
LOOP
    INSERT INTO ЗАЧЕТ(ном_студ)
        VALUES (V_COUNTER);
        V_COUNTER := V_COUNTER + 1;
    EXIT WHEN V_COUNTER > 20;
END LOOP;
```

### Числовые циклы FOR

Число итераций в простых циклах и циклах заранее неизвестно — оно зависит от условий, заданных в циклах. В числовых же циклах ``FOR`` число итераций заранее определено. Имеет место следующий синтаксис:

```sql
FOR счетчик_цикла IN [ REVERSE ]
нижняя_граница..верхняя_граница
LOOP последовательность_операторов
END LOOP;
```

где
* ``счетчик_цикла`` — неявно создаваемая индексная переменная;
* ``нижняя_граница`` и ``верхняя_граница`` указывают число итераций;
* ``последовательность_операторов`` — содержимое цикла.

Опишем предыдущий пример:

```sql
BEGIN
    FOR V_COUNTER IN 1..20 LOOP
        INSERT INTO ЗАЧЕТ(ном_студ)
        VALUES (V_COUNTER);
    END LOOP;
END;
```

## Именованные блоки PL/SQL (процедуры, функции, триггеры)

### Процедуры

**Процедура** — это блок PL/SQL, в состав которого входят раздел объявлений, выполняемый раздел и раздел исключительных ситуаций. Необходимым является только выполняемый раздел.

Синтаксис оператора ``CREATE OR REPLACE PROCEDURE`` таков:

```sql
CREATE [ OR REPLACE ] PROCEDURE имя_процедуры
[ { аргумент[ { IN | OUT | IN OUT } ] тип,
    ...
[ { аргумент[{ IN | OUT | IN OUT }] тип ) ] { IS | AS }
тело процедуры
```

где
* ``имя_процедуры`` — это имя создаваемой процедуры;
* ``аргумент`` — имя параметра процедуры;
* ``тип`` — это тип соответствующего параметра;
* ``тело_процедуры`` — блок PL/SQL, в котором содержится текст процедуры.

Для изменения текста процедуры необходимо удалить и вновь создать её. Во время разработки процедур эта операция достаточно часто выполняется, что создаёт определённые трудности. Поэтому ключевые слова ``OR REPLACE`` (заменить) позволяют выполнить эту операцию за один раз. Если процедура существует, она удаляется без всякого предупреждения (для чего используется команда ``DROP PROCEDURE``). Если процедура до этого не существовала, то её необходимо создать. Если же процедура существует, но ключевые слова ``OR REPLACE`` позволяют изменить её текст при разработке. Использование ``OR REPLACE`` также необходимо при разработке функций и триггеров (синтаксис использования одинаков).

Как и другие операторы ``CREATE``, создание процедуры является операцией DDL, поэтому до и после создания процедуры неявно выполняются операторы ``COMMIT``, необходимые для внесения изменений в память (то есть ``COMMIT`` — это завершение операции транзакции).

При этом можно использовать эквивалентные друг другу слова ``IS`` и ``AS``, которые используются при описании процедуры вместо ``DECLARE``.

**Тело процедуры** — это блок PL/SQL, содержащий раздел объявлений, выполняемый раздел и раздел исключительных ситуаций. Раздел объявлений располагается между ключевыми словами ``IS`` (``AS``) и ключевым словом ``BEGIN``. Выполняемый раздел (единственный, который обязателен) находится между ключевыми словами ``BEGIN`` и ``EXCEPTION``. Раздел исключительных ситуаций находится между ключевыми словами ``EXCEPTION`` и ``END``.

Процедура вызывается явным образом из другого блока, причём при вызове процедуры ей могут передаваться различные аргументы.

Таким образом:

```sql
CREATE [ OR REPLACE ] PROCEDURE имя_процедуры AS
    /* раздел объявлений */
BEGIN
    /* выполняемый раздел */
EXCEPTION
    /* раздел исключительных ситуаций */
END имя_процедуры;
```

#### NO_DATA_FOUND и %NOTFOUND

Исключительная ситуация ``NO_DATA_FOUND`` (данные не зайдены) устанавливается только для операторов ``SELECT..INTO``, когда условие запроса не соответствует ни одна из строк. В этом случае атрибут ``%NOTFOUND`` принимает значение ``TRUE``. Если не соответствия строкам в условии оператора ``UPDATE`` или ``DELETE``, ``SQL%NOTFOUND`` также принимает значение ``TRUE``. Поэтому во всех циклах выборки для определения условия выхода из цикла используется не исключительная ситуация ``NO_DATA_FOUND``, а атрибуты ``%NOTFOUND`` или ``%FOUND``.

**Для отладки** процедуры необходимо набрать текст процедуры в окне **Program Window** и нажать клавишу **F8**. При наличии ошибок выдаётся сообщение об ошибках. Если же объект скомпилирован нормально, то сообщений об ошибке выдаваться не будут.

**Для запуска** Процедуры необходимо указать мышкой на нужный объект в окне, показывающем базу, и **нажать правую кнопку мыши**. В появившемся меню выбрать пункт **Test**. После этого необходимо в нижнем из появившихся окон задать параметры, имеющиеся у объекта, и нажать клавишу **F8**.

**Для обновления** объектов базы необходимо выбрать пункт **Refresh** (меню появится при нажатии на правую кнопку мыши, указывающей на нужный объект).

### Функции

Синтаксис для создания функций очень похож на синтаксис для создания процедуры:

```sql
CREATE [ OR REPLACE ] FUNCTION имя_функции
[ { аргумент[{ IN | OUT | IN OUT } ] тип,
    ...
[ { аргумент[{ IN | OUT | IN OUT } ] тип )]
RETURN возвращаемый тип {IS | AS}
тело_функции
```
где
* ``имя_функции`` — это имя функции;
* ``аргумент`` и ``тип`` аналогичны аргументу и типу, указываемому при создании процедуры;
* ``возвращаемый_тип`` — это тип значения, возвращаемого функцией;
* ``тело_функции`` — блок PL/SQL, содержащий программный текст данной функции.

#### Оператор RETURN

Внутри тела функции оператор ``RETURN`` применяется для возврата управления программой и результата выполнения функции в вызывающую среду. Общий синтаксис оператора ``RETURN`` выглядит следующим образом:

```sql
RETURN выражение;
```

где ``выражение`` — это возвращаемое значение. Значение выражения преобразуется к типу, указанному в команде ``RETURN`` при описании функции, если это значение уже не имеет данный тип. При выполнении оператора ``RETURN`` управление программой сразу же возвращается в вызванную среду.

В функции может быть несколько операторов ``RETURN``, хотя выполняться будет только один из них. Завершение функции без оператора ``RETURN`` является ошибкой.

### Триггеры

**Триггеры** являются именованными блоками PL/SQL с разделом объявлений, выполняемым разделом и разделом исключительных ситуаций. Триггер выполняется неявно, всякий раз, когда происходит событие, запускающее этот триггер, причём использование аргументов не допускается. Акт выполнения триггера называется его *активацией* (firing). **Запускается триггер** операцией DML (``INSERT``, ``UPDATE`` или ``DELETE``) выполняемой над базой данных.

Общий синтаксис создания триггера:

```sql
CREATE [ OR REPLACE ] TRIGGER имя_триггера
{ BEFORE | AFTER } активизирующее_событие ON ссылка_на_таблицу
[ FOR EACH ROW [ WHEN условие_срабатывания ] ]
тело_триггера;
```

где
* ``имя_триггера`` — это имя триггера;
* ``активизирующее_событие`` — момент активизации триггера (``INSERT``, ``DELETE``, ``UPDATE``);
* ``ссылка_на_таблицу`` — таблица, для которой создан триггер;
* ``тело_триггера`` — программны текст триггера.

Если присутствует ``условие_срабатывания`` в условии ``WHEN`` (когда), то вначале вычисляется оно, а тело триггера выполняется только в том случае, если это условие истинно.

Для триггера существует два уровня — *операторный* и *строковый* (присутствует условие ``FOR EACH ROW``). Если триггер является строковым, то он срабатывает каждый раз для строки, обрабатываемой активизирующим оператором. Если триггер является операторным, 